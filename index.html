<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Only For You Â· E.dan</title>
    <style>
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background: #000; font-family: "PingFang SC", -apple-system, BlinkMacSystemFont, Roboto, sans-serif; }
        #app { position: absolute; inset: 0; height: var(--vh, 100vh); width: 100vw; background: radial-gradient(circle at center, #070712 0%, #000 100%); overflow: hidden; }
        canvas { display:block; width:100%; height:100%; outline:none; }

        /* é¡¶éƒ¨æ ‡ç­¾ï¼šå¼ºå¯¹æ¯” + èƒ¶å›Šåº• */
        #stage-label{
            position:absolute; top: 14px; left:50%;
            transform: translateX(-50%);
            z-index: 30; pointer-events:none;
            font-size: 14px; letter-spacing: 2px; font-weight: 650;
            padding: 8px 14px; border-radius: 999px;
            background: rgba(0,0,0,0.38);
            border: 1px solid rgba(255,255,255,0.18);
            backdrop-filter: blur(10px);
            color: rgba(255,255,255,0.96);
            text-shadow:
                    0 1px 0 rgba(0,0,0,0.55),
                    0 0 12px rgba(255,255,255,0.25),
                    0 0 22px rgba(255,170,215,0.20);
        }

        /* å·¦ä¾§ä¼˜é›…æ–‡å­— */
        #left-text{
            position:absolute; left: 18px; top: 44%;
            transform: translateY(-50%);
            z-index: 9; pointer-events: none;
            color: rgba(255,255,255,0.92);
            font-family: "Times New Roman", Georgia, serif;
            font-style: italic;
            text-shadow: 0 0 10px rgba(255,255,255,0.25);
            opacity: 0.9;
            line-height: 1.25;
        }
        #left-text .title{ font-size: 26px; }
        #left-text .sub{ font-size: 18px; opacity: 0.85; }

        /* ç»ˆæè¡¨ç™½å¼¹çª— */
        #final-overlay{
            position:absolute; inset:0; display:none;
            align-items:center; justify-content:center; z-index: 100;
            backdrop-filter: blur(12px);
            background: rgba(0,0,0,0.62);
            transition: opacity .5s;
        }
        .box{
            background: rgba(24, 10, 20, 0.88);
            border-radius: 24px;
            padding: 32px 24px;
            width: 80%; max-width: 320px;
            text-align:center;
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 0 55px rgba(255,200,230,0.16);
            animation: popIn .6s cubic-bezier(.175,.885,.32,1.275);
        }
        @keyframes popIn { from { transform: scale(.5); opacity:0; } to { transform: scale(1); opacity:1; } }
        .question{ font-size: 20px; color:#fff; margin-bottom: 24px; line-height:1.5; font-weight: 300; }
        .highlight{ color:#ff9fcf; font-weight: 700; }
        #yes-btn{
            padding: 12px 36px;
            border-radius: 999px;
            border: none;
            font-size: 16px;
            cursor:pointer;
            color:#fff;
            background: linear-gradient(135deg, #ff95d0, #ff5fb5);
            box-shadow: 0 10px 26px rgba(255,120,190,0.35);
            transition: transform .2s, filter .2s;
        }
        #yes-btn:active{ transform: scale(.96); }
        #yes-btn:hover{ filter: brightness(1.06); }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #mobile-controls{
            position:absolute; bottom: 26px; left:0; right:0;
            display:flex; flex-direction: column; gap: 12px;
            padding: 0 20px;
            z-index: 20;
        }
        .row{ display:flex; gap: 10px; justify-content:center; }
        .ctrl-btn{
            flex: 1;
            padding: 12px 0;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.88);
            font-size: 13px;
            backdrop-filter: blur(10px);
            transition: background .2s, transform .2s;
        }
        .ctrl-btn:active{ background: rgba(255,255,255,0.16); transform: scale(.99); }
        .primary{ border-color: rgba(255,170,215,0.30); color: rgba(255,235,245,0.92); }
    </style>
</head>

<body>
<div id="app">
    <div id="stage-label">âœ¨ The Starry Tree âœ¨</div>

    <div id="left-text">
        <div class="title">Merry Christmas</div>
        <div class="sub" id="left-sub">âœ¨</div>
    </div>

    <div id="final-overlay">
        <div class="box">
            <div class="question">To <span class="highlight">E.dan</span><br>è¿™ä¸ªåœ£è¯èŠ‚<br>åšæˆ‘å¥³æœ‹å‹å¥½å—ï¼ŸğŸ„</div>
            <button id="yes-btn">æˆ‘æ„¿æ„ â¤ï¸</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="row">
            <button class="ctrl-btn" id="boom-btn">ğŸ’¥ çˆ†ç‚¸</button>
            <button class="ctrl-btn primary" id="fire-btn">ğŸ† çƒŸèŠ±</button>
            <button class="ctrl-btn" id="theme-btn">ğŸ¨ æ¢è‰²</button>
        </div>
        <div class="row">
            <button class="ctrl-btn" id="prev-btn">â—€ ä¸Šä¸€å¹•</button>
            <button class="ctrl-btn" id="next-btn">ä¸‹ä¸€å¹• â–¶</button>
        </div>
    </div>
</div>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
        "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
        "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js",

        "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
        "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
        "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js",
        "three/examples/jsm/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"
      }
    }
</script>

<script type="module">
    function fixVh() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh * 100}px`);
    }
    fixVh(); window.addEventListener('resize', fixVh);

    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';

    // =========================
    // ä¸»é¢˜ï¼ˆä½é¥±å’Œç²‰ç™½ + å…‹åˆ¶é«˜å…‰ï¼‰
    // =========================
    const CONFIG = {
        themes: [
            { name:"ç²‰ç™½é›ªå¤œ", bg:'#05050b', fog:'#070710', a:0xffcfe3, b:0xffffff, star:0xffffff },
            { name:"æš–ç²‰åœ£è¯", bg:'#06040a', fog:'#080510', a:0xffb6d6, b:0xfff4fb, star:0xfff6ff },
            { name:"å†·ç²‰æå…‰", bg:'#050612', fog:'#07071a', a:0xffc7e2, b:0xeef8ff, star:0xffffff },
        ],
        tree: { yMin:-23, yMax:23, rMax:18, count:14000 },
        vortex: { baseY:-20.5, height:18.0, turns:3.2, rStart:26, rEnd:6, bands:6, pointsPerBand:2600 }
    };
    let colorIdx = 0;

    // =========================
    // åœºæ™¯
    // =========================
    const app = document.getElementById('app');
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1600);
    camera.position.set(0, 12, 54);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    app.appendChild(renderer.domElement);

    // å…³é”®ï¼šè‰²è°ƒæ˜ å°„å‹é«˜å…‰ï¼ˆè§£å†³â€œäº®ç³Šä¸€å¨â€ï¼‰
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.85;
    renderer.physicallyCorrectLights = true;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.55;
    controls.maxDistance = 140;
    controls.minDistance = 12;

    function applyTheme() {
        const th = CONFIG.themes[colorIdx];
        scene.background = new THREE.Color(th.bg);
        scene.fog = new THREE.FogExp2(new THREE.Color(th.fog), 0.010);
        document.getElementById('left-sub').textContent = th.name;
    }
    applyTheme();

    scene.add(new THREE.AmbientLight(0xffffff, 0.18));
    const key = new THREE.DirectionalLight(0xffffff, 0.48);
    key.position.set(18, 30, 24);
    scene.add(key);
    const fill = new THREE.PointLight(0xffb9df, 0.36, 180);
    fill.position.set(-16, 10, 18);
    scene.add(fill);

    // å‘å…‰ç‚¹çº¹ç†
    function createPointTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(32,32,0, 32,32,32);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.35, 'rgba(255,255,255,0.55)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
        const tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        return tex;
    }
    const glowTex = createPointTexture();

    // =========================
    // âœ… é€‰æ‹©æ€§ Bloomï¼ˆåªè®©â€œæ ‘é¡¶æ˜Ÿ/çƒŸèŠ±/çˆ†ç‚¸â€Bloomï¼Œå…¶å®ƒç‚¹äº‘ä¸Bloomï¼‰
    // =========================
    const BLOOM_LAYER = 1;
    const bloomLayer = new THREE.Layers();
    bloomLayer.set(BLOOM_LAYER);

    const darkMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const materials = new Map();

    // Bloom passï¼ˆå•ç‹¬æ¸²æŸ“ä¸€å¼  bloom çº¹ç†ï¼‰
    const bloomComposer = new EffectComposer(renderer);
    bloomComposer.renderToScreen = false;
    bloomComposer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.55,  // strengthï¼šå…‹åˆ¶
        0.22,  // radius
        0.42   // thresholdï¼šæé«˜é˜ˆå€¼ï¼Œé¿å…æ•´å±æ³›å…‰
    );
    bloomComposer.addPass(bloomPass);

    // Final passï¼šæŠŠ bloom çº¹ç†å åŠ åˆ°æ­£å¸¸æ¸²æŸ“ä¸Š
    const finalComposer = new EffectComposer(renderer);
    finalComposer.addPass(new RenderPass(scene, camera));

    const finalPass = new ShaderPass(new THREE.ShaderMaterial({
        uniforms: {
            baseTexture: { value: null },
            bloomTexture: { value: bloomComposer.renderTarget2.texture }
        },
        vertexShader: `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
        fragmentShader: `
      varying vec2 vUv;
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;

      void main(){
        vec4 base = texture2D(baseTexture, vUv);
        vec4 bloom = texture2D(bloomTexture, vUv);
        gl_FragColor = base + bloom;   // Additive å åŠ 
      }
    `
    }), "baseTexture");
    finalComposer.addPass(finalPass);

    function darkenNonBloomed(obj) {
        if (obj.isMesh || obj.isPoints || obj.isSprite) {
            const isBloom = bloomLayer.test(obj.layers);
            if (!isBloom) {
                materials.set(obj.uuid, obj.material);
                obj.material = darkMaterial;
            }
        }
    }
    function restoreMaterial(obj) {
        const mat = materials.get(obj.uuid);
        if (mat) {
            obj.material = mat;
            materials.delete(obj.uuid);
        }
    }

    // =========================
    // æ˜Ÿç©ºï¼ˆä¸ Bloomï¼Œä¿æŒç‚¹åˆ†ç¦»ï¼‰
    // =========================
    const starGroup = new THREE.Group();
    scene.add(starGroup);

    function buildStars() {
        while (starGroup.children.length) {
            const o = starGroup.children.pop();
            o.geometry?.dispose?.();
            o.material?.dispose?.();
        }

        const layers = [
            { count: 1600, spread: 260, size: 0.55, opacity: 0.42, rot: 0.006 },
            { count: 900,  spread: 220, size: 0.85, opacity: 0.32, rot: -0.004 },
            { count: 520,  spread: 200, size: 1.10, opacity: 0.22, rot: 0.002 },
        ];

        layers.forEach(cfg => {
            const pos = new Float32Array(cfg.count * 3);
            const col = new Float32Array(cfg.count * 3);

            for (let i = 0; i < cfg.count; i++) {
                const r = cfg.spread * (0.55 + Math.random() * 0.45);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                pos[i*3]   = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.cos(phi);
                pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);

                const base = new THREE.Color(0xffffff);
                base.lerp(new THREE.Color(0xffd6e8), 0.18 + Math.random() * 0.12);
                col[i*3] = base.r; col[i*3+1] = base.g; col[i*3+2] = base.b;
            }

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            g.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const m = new THREE.PointsMaterial({
                size: cfg.size,
                map: glowTex,
                transparent: true,
                opacity: cfg.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const pts = new THREE.Points(g, m);
            pts.userData.rot = cfg.rot;
            starGroup.add(pts);
        });
    }
    buildStars();

    // =========================
    // ğŸ„ ä½“ç§¯ç‚¹äº‘æ ‘ï¼ˆä¸ Bloomï¼Œé  toneMapping ä¿æŒæ¸…æ™°ï¼‰
    // =========================
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);
    let treeGeometry = null;
    let treeMat = null;
    let treeTopStar = null;

    function createTreeShaderMaterial() {
        const th = CONFIG.themes[colorIdx];
        return new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            uniforms: {
                uTime: { value: 0 },
                uColorA: { value: new THREE.Color(th.a) },
                uColorB: { value: new THREE.Color(th.b) },
                uIntensity: { value: 0.78 }, // é™ä¸€ç‚¹ï¼Œé¿å…å³°å€¼ç‚¸ç™½
                uTwinkle: { value: 0.80 },
                uPointScale: { value: 0.80 }
            },
            vertexShader: `
        attribute float aSize;
        attribute float aPhase;
        attribute float aP;

        varying float vP;
        varying float vGlow;
        varying float vPhase;

        uniform float uTime;
        uniform float uTwinkle;
        uniform float uPointScale;

        void main() {
          vP = aP;
          vPhase = aPhase;

          vec3 pos = position;

          float drift = (sin(uTime*0.55 + aPhase) * 0.16 + sin(uTime*1.0 + aP*10.0) * 0.10);
          pos.x += drift * (1.0 - aP) * 0.55;
          pos.z -= drift * (1.0 - aP) * 0.55;

          float tw = sin(uTime*2.6 + aPhase) * 0.5 + 0.5;
          tw = mix(tw, pow(tw, 3.0), 0.55);
          vGlow = mix(0.55, 1.25, tw) * uTwinkle;

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          float dist = max(1.0, -mv.z);
          float size = aSize * (250.0 / dist) * uPointScale;
          size *= (0.92 + 0.18 * sin(uTime*1.6 + aPhase));
          gl_PointSize = clamp(size, 1.0, 70.0);
        }
      `,
            fragmentShader: `
        precision highp float;

        varying float vP;
        varying float vGlow;
        varying float vPhase;

        uniform float uTime;
        uniform vec3 uColorA;
        uniform vec3 uColorB;
        uniform float uIntensity;

        void main() {
          vec2 uv = gl_PointCoord.xy - 0.5;
          float d = length(uv);

          float core = smoothstep(0.22, 0.0, d);
          float halo = smoothstep(0.70, 0.18, d);

          vec3 col = mix(uColorA, uColorB, smoothstep(0.0, 1.0, vP));
          col += 0.02 * sin(vec3(1.7,2.3,2.9) * (uTime*0.55 + vPhase));

          float alpha = (core * 0.86 + halo * 0.44) * vGlow;
          alpha *= (1.05 - smoothstep(0.36, 0.86, d));
          if(alpha < 0.02) discard;

          vec3 outCol = col * (uIntensity * (0.55 + 0.85*core + 0.35*halo));
          outCol = clamp(outCol, 0.0, 1.15);

          gl_FragColor = vec4(outCol, alpha);
        }
      `
        });
    }

    function createVolumetricTree() {
        if (treeGeometry) treeGeometry.dispose();
        if (treeMat) treeMat.dispose();

        const count = CONFIG.tree.count;
        const positions = new Float32Array(count * 3);
        const aSize = new Float32Array(count);
        const aPhase = new Float32Array(count);
        const aP = new Float32Array(count);

        const yMin = CONFIG.tree.yMin;
        const yMax = CONFIG.tree.yMax;
        const rMaxAll = CONFIG.tree.rMax;

        for (let i = 0; i < count; i++) {
            const p = i / (count - 1);
            const y = yMin + p * (yMax - yMin);
            const rMax = (1 - p) * rMaxAll;

            const density = 0.25 + 0.75 * Math.pow(1 - Math.abs(p - 0.55) * 1.6, 2);
            const rr = rMax * Math.sqrt(Math.random()) * (0.55 + 0.45 * density);
            const ang = Math.random() * Math.PI * 2;
            const swirl = 0.65 * Math.sin(p * 14.0 + ang * 0.35);

            let x = Math.cos(ang) * rr + swirl * (1 - p) * 0.35;
            let z = Math.sin(ang) * rr - swirl * (1 - p) * 0.35;

            x += (Math.random() - 0.5) * 0.55;
            z += (Math.random() - 0.5) * 0.55;

            positions[i*3]   = x;
            positions[i*3+1] = y + (Math.random() - 0.5) * 0.25;
            positions[i*3+2] = z;

            aP[i] = p;
            aPhase[i] = Math.random() * Math.PI * 2;
            aSize[i] = (0.9 + Math.random() * 1.8) * (1.25 - p * 0.85);
        }

        treeGeometry = new THREE.BufferGeometry();
        treeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        treeGeometry.setAttribute('aSize', new THREE.BufferAttribute(aSize, 1));
        treeGeometry.setAttribute('aPhase', new THREE.BufferAttribute(aPhase, 1));
        treeGeometry.setAttribute('aP', new THREE.BufferAttribute(aP, 1));

        treeMat = createTreeShaderMaterial();

        while (treeGroup.children.length) treeGroup.remove(treeGroup.children[0]);
        treeGroup.add(new THREE.Points(treeGeometry, treeMat));

        // æ ‘é¡¶æ˜Ÿï¼šæ”¾åˆ° Bloom Layerï¼ˆåªå®ƒ Bloomï¼‰
        if (treeTopStar) {
            treeTopStar.material.dispose();
            treeGroup.remove(treeTopStar);
        }
        const th = CONFIG.themes[colorIdx];
        treeTopStar = new THREE.Sprite(new THREE.SpriteMaterial({
            map: glowTex,
            color: new THREE.Color(th.star),
            transparent: true,
            opacity: 0.65,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        }));
        treeTopStar.position.set(0, yMax + 0.8, 0);
        treeTopStar.scale.set(7.5, 7.5, 1);
        treeTopStar.layers.enable(BLOOM_LAYER);
        treeGroup.add(treeTopStar);
    }
    createVolumetricTree();

    // =========================
    // ğŸŒ€ æ—‹æ¶¡ç‚¹äº‘ï¼ˆä¸ Bloomï¼Œå‹ opacity/size ä¿æŒç»“æ„æ¸…æ™°ï¼‰
    // =========================
    const vortexGroup = new THREE.Group();
    scene.add(vortexGroup);

    let vortexGeos = [];
    let vortexMats = [];

    function disposeVortex() {
        vortexGeos.forEach(g => g.dispose?.());
        vortexMats.forEach(m => m.dispose?.());
        vortexGeos = []; vortexMats = [];
        while (vortexGroup.children.length) vortexGroup.remove(vortexGroup.children[0]);
    }

    function buildVortex() {
        disposeVortex();
        const th = CONFIG.themes[colorIdx];
        const baseY = CONFIG.vortex.baseY;

        for (let b = 0; b < CONFIG.vortex.bands; b++) {
            const count = CONFIG.vortex.pointsPerBand;
            const pos = new Float32Array(count * 3);
            const col = new Float32Array(count * 3);

            const bandHeightShift = (b - (CONFIG.vortex.bands - 1) / 2) * 0.35;
            const thickness = 0.55 + b * 0.08;
            const localTurns = CONFIG.vortex.turns + (b - 2) * 0.10;

            for (let i = 0; i < count; i++) {
                const p = i / (count - 1);
                const y = baseY + p * CONFIG.vortex.height + bandHeightShift;

                const rBase = THREE.MathUtils.lerp(CONFIG.vortex.rStart, CONFIG.vortex.rEnd, p);
                const jitterR = (Math.random() - 0.5) * thickness * 1.35;
                const r = rBase + jitterR;

                const ang = p * Math.PI * 2 * localTurns + b * 0.6 + (Math.random() - 0.5) * 0.04;
                const cross = (Math.random() - 0.5) * thickness;

                pos[i*3]   = Math.cos(ang) * (r + cross) + (Math.random()-0.5)*0.12;
                pos[i*3+1] = y + (Math.random()-0.5)*0.16;
                pos[i*3+2] = Math.sin(ang) * (r - cross) + (Math.random()-0.5)*0.12;

                const c = new THREE.Color(th.a).lerp(new THREE.Color(th.b), 0.55 + 0.45 * p);
                col[i*3] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
            }

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            g.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const m = new THREE.PointsMaterial({
                size: 0.45 + b * 0.04,
                map: glowTex,
                transparent: true,
                opacity: 0.18,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const pts = new THREE.Points(g, m);
            pts.userData = { band: b, speed: 0.18 + b * 0.02, wobble: 0.22 + b * 0.02 };
            vortexGroup.add(pts);

            vortexGeos.push(g);
            vortexMats.push(m);
        }

        // åº•éƒ¨é›¾æµ·ç›˜ï¼ˆæ›´å…‹åˆ¶ï¼Œé¿å…ç³Šï¼‰
        {
            const count = 9000;
            const pos = new Float32Array(count * 3);
            const col = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const rr = (18 + Math.random() * 38) * Math.sqrt(Math.random());
                const ang = Math.random() * Math.PI * 2;

                pos[i*3]   = Math.cos(ang) * rr + (Math.random()-0.5)*0.25;
                pos[i*3+1] = baseY + (Math.random()-0.5)*1.4;
                pos[i*3+2] = Math.sin(ang) * rr + (Math.random()-0.5)*0.25;

                const c = new THREE.Color(th.a).lerp(new THREE.Color(0xffffff), 0.55 + Math.random() * 0.35);
                col[i*3] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
            }

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            g.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const m = new THREE.PointsMaterial({
                size: 0.42,
                map: glowTex,
                transparent: true,
                opacity: 0.14,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const disk = new THREE.Points(g, m);
            disk.userData = { isDisk: true };
            vortexGroup.add(disk);

            vortexGeos.push(g);
            vortexMats.push(m);
        }
    }
    buildVortex();

    // =========================
    // â„ï¸ é£˜é›ªï¼ˆä¸ Bloomï¼‰
    // =========================
    const snowMat = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        uniforms: { uTime: { value: 0 }, uTex: { value: glowTex } },
        vertexShader: `
      attribute float aSize;
      attribute float aSpeed;
      attribute float aDrift;
      attribute float aPhase;
      varying float vAlpha;
      uniform float uTime;

      void main() {
        vec3 pos = position;
        pos.y -= mod(uTime * aSpeed + aPhase, 90.0);
        pos.x += sin(uTime * 0.55 + aPhase) * aDrift;
        pos.z += cos(uTime * 0.50 + aPhase) * aDrift;

        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mv;

        float dist = max(1.0, -mv.z);
        gl_PointSize = clamp(aSize * (250.0 / dist), 1.0, 22.0);
        vAlpha = clamp(1.0 / (0.032 * dist), 0.10, 0.85);
      }
    `,
        fragmentShader: `
      precision highp float;
      varying float vAlpha;
      uniform sampler2D uTex;

      void main() {
        vec4 tex = texture2D(uTex, gl_PointCoord);
        float a = tex.a * vAlpha;
        if(a < 0.03) discard;
        vec3 col = vec3(0.92, 0.97, 1.0) * 0.78;
        gl_FragColor = vec4(col, a);
      }
    `
    });

    const snow = new THREE.Points(new THREE.BufferGeometry(), snowMat);
    scene.add(snow);

    function buildSnow() {
        const count = 2200;
        const pos = new Float32Array(count * 3);
        const size = new Float32Array(count);
        const speed = new Float32Array(count);
        const drift = new Float32Array(count);
        const phase = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            pos[i*3]   = (Math.random() - 0.5) * 140;
            pos[i*3+1] = Math.random() * 90 + 10;
            pos[i*3+2] = (Math.random() - 0.5) * 160;

            const z = Math.abs(pos[i*3+2]);
            const depthFactor = 1.0 - Math.min(z / 160, 1.0);

            size[i] = (0.8 + Math.random() * 2.0) * (0.55 + depthFactor);
            speed[i] = 2.2 + Math.random() * 5.5;
            drift[i] = 0.06 + Math.random() * 0.20;
            phase[i] = Math.random() * 90.0;
        }

        snow.geometry.dispose();
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        g.setAttribute('aSize', new THREE.BufferAttribute(size, 1));
        g.setAttribute('aSpeed', new THREE.BufferAttribute(speed, 1));
        g.setAttribute('aDrift', new THREE.BufferAttribute(drift, 1));
        g.setAttribute('aPhase', new THREE.BufferAttribute(phase, 1));
        snow.geometry = g;
    }
    buildSnow();

    // =========================
    // ğŸ’– çˆ±å¿ƒï¼ˆä¸ Bloomï¼Œä¿æŒè´¨æ„Ÿï¼‰
    // =========================
    const heartGroup = new THREE.Group();
    scene.add(heartGroup);

    const heartShape = new THREE.Shape();
    heartShape.moveTo(0, 0);
    heartShape.bezierCurveTo(0, 3, -3, 3, -3, 0);
    heartShape.bezierCurveTo(-3, -3, 3, -3, 3, 0);
    heartShape.bezierCurveTo(3, 3, 0, 3, 0, 0);

    const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth:2, bevelEnabled:true, bevelSegments:3, steps:2, bevelSize:0.5, bevelThickness:0.5 });
    heartGeo.center();

    const heartMesh = new THREE.Mesh(heartGeo, new THREE.MeshPhongMaterial({
        color: 0xff7cbc, emissive: 0x2b0017, shininess: 180, specular: 0xffffff
    }));
    heartMesh.scale.set(2,2,2);
    heartGroup.add(heartMesh);

    const haloGeo = new THREE.BufferGeometry();
    const haloPos = [];
    for (let i=0;i<240;i++){
        const t = i/240*Math.PI*2;
        const r = 8.5 + Math.random()*0.8;
        haloPos.push(Math.cos(t)*r, (Math.random()-0.5)*2.2, Math.sin(t)*r);
    }
    haloGeo.setAttribute('position', new THREE.Float32BufferAttribute(haloPos,3));
    const heartHalo = new THREE.Points(haloGeo, new THREE.PointsMaterial({
        color: 0xffcfe3, size: 0.32, transparent:true, opacity:0.7,
        blending: THREE.AdditiveBlending, depthWrite:false
    }));
    heartGroup.add(heartHalo);
    heartGroup.visible = false;

    // =========================
    // ğŸ“ ç²’å­æ–‡å­—
    // =========================
    const particleMat = new THREE.PointsMaterial({
        size: 0.75,
        map: glowTex,
        transparent: true,
        opacity: 0.9,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const textGroup = new THREE.Group();
    scene.add(textGroup);
    let textParticles = [];

    const fontLoader = new FontLoader();
    fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
        function generateText(text, y, color) {
            const geo = new TextGeometry(text, { font, size: 3.5, height: 0.2, curveSegments: 6 });
            geo.center();

            const ptr = geo.attributes.position.array;
            const pts = [];
            const cols = [];
            const c = new THREE.Color(color);

            for (let i = 0; i < ptr.length; i += 3) {
                if (Math.random() > 0.62) continue;
                pts.push(ptr[i], ptr[i+1] + y, ptr[i+2]);
                cols.push(c.r, c.g, c.b);
            }

            const buf = new THREE.BufferGeometry();
            buf.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
            buf.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));

            const p = new THREE.Points(buf, particleMat);
            p.userData = { velocities: new Array(pts.length/3).fill(0).map(()=>({x:0,y:0,z:0})), exploding:false };
            textGroup.add(p);
            textParticles.push(p);
        }

        generateText('Merry', 4, 0xffcfe3);
        generateText('Christmas', -2, 0xffffff);
        textGroup.visible = false;
    });

    // =========================
    // ğŸ† çƒŸèŠ±ï¼ˆæ”¾åˆ° Bloom Layerï¼Œåªæœ‰çƒŸèŠ± Bloomï¼‰
    // =========================
    const fireworks = [];
    function launchFirework() {
        const x = (Math.random()-0.5) * 40;
        const y = Math.random() * 20 + 10;
        const z = (Math.random()-0.5) * 40;

        const color = new THREE.Color(0xffffff).lerp(new THREE.Color(0xffb6d6), Math.random()*0.5);

        const count = 160;
        const pos = new Float32Array(count * 3);
        const vel = [];

        for(let i=0; i<count; i++) {
            pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 0.50 + 0.22;
            vel.push({ x: Math.cos(angle)*speed, y: (Math.random()-0.5)*speed + 0.18, z: Math.sin(angle)*speed });
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({
            size: 0.62,
            map: glowTex,
            color,
            transparent: true,
            opacity: 0.95,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const sys = new THREE.Points(geo, mat);
        sys.layers.enable(BLOOM_LAYER);
        scene.add(sys);
        fireworks.push({ sys, vel, life: 1.0 });
    }

    // =========================
    // ğŸ’¥ çˆ†ç‚¸ï¼ˆæ”¾åˆ° Bloom Layerï¼‰
    // =========================
    const bursts = [];
    function spawnBurst(pos, baseColor = 0xffd1e8) {
        const count = 1200;
        const p = new Float32Array(count * 3);
        const v = new Float32Array(count * 3);
        const cols = new Float32Array(count * 3);

        const c = new THREE.Color(baseColor);

        for (let i = 0; i < count; i++) {
            p[i*3]   = pos.x + (Math.random()-0.5) * 0.8;
            p[i*3+1] = pos.y + (Math.random()-0.5) * 0.8;
            p[i*3+2] = pos.z + (Math.random()-0.5) * 0.8;

            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2*Math.random()-1);
            const speed = 0.25 + Math.random() * 1.10;

            v[i*3]   = Math.sin(phi) * Math.cos(theta) * speed;
            v[i*3+1] = Math.cos(phi) * speed + 0.33;
            v[i*3+2] = Math.sin(phi) * Math.sin(theta) * speed;

            const mix = Math.random();
            const cc = c.clone().lerp(new THREE.Color(0xffffff), mix*0.65);
            cols[i*3] = cc.r; cols[i*3+1] = cc.g; cols[i*3+2] = cc.b;
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(p, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

        const mat = new THREE.PointsMaterial({
            size: 0.55,
            map: glowTex,
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const sys = new THREE.Points(geo, mat);
        sys.layers.enable(BLOOM_LAYER);
        scene.add(sys);
        bursts.push({ sys, vel: v, life: 1.0 });
    }

    // =========================
    // ğŸ® æµç¨‹
    // =========================
    let step = 1;
    const overlay = document.getElementById('final-overlay');
    const label = document.getElementById('stage-label');

    function setStep(v) {
        step = v;
        treeGroup.visible = false;
        heartGroup.visible = false;
        textGroup.visible = false;
        overlay.style.display = 'none';

        vortexGroup.visible = true;
        document.getElementById('left-text').style.opacity = (step === 1 || step === 4) ? '0.92' : '0.35';

        if(step === 1) { treeGroup.visible = true; label.innerText = "âœ¨ The Starry Tree âœ¨"; }
        else if(step === 2) { heartGroup.visible = true; label.innerText = "ğŸ’– My Heart For You ğŸ’–"; }
        else if(step === 3) { textGroup.visible = true; label.innerText = "ğŸ„ Best Wishes ğŸ„"; }
        else if(step === 4) { treeGroup.visible = true; overlay.style.display = 'flex'; label.innerText = "ğŸ’Œ A Question... ğŸ’Œ"; }
    }

    document.getElementById('next-btn').onclick = () => { if(step < 4) setStep(step+1); };
    document.getElementById('prev-btn').onclick = () => { if(step > 1) setStep(step-1); };

    document.getElementById('theme-btn').onclick = () => {
        colorIdx = (colorIdx + 1) % CONFIG.themes.length;
        applyTheme();
        createVolumetricTree();
        buildVortex();
        buildStars();
    };

    document.getElementById('fire-btn').onclick = launchFirework;

    document.getElementById('boom-btn').onclick = () => {
        if (step === 3 && textParticles.length > 0) {
            textParticles.forEach(p => {
                p.userData.exploding = true;
                p.userData.velocities.forEach(v => {
                    v.x = (Math.random()-0.5) * 1.2;
                    v.y = (Math.random()-0.5) * 1.2;
                    v.z = (Math.random()-0.5) * 1.2;
                });
                p.material.opacity = 0.95;
            });
            return;
        }

        const th = CONFIG.themes[colorIdx];
        spawnBurst(new THREE.Vector3(0, 2, 0), th.a);
        spawnBurst(new THREE.Vector3(0, CONFIG.vortex.baseY + 10, 0), th.b);
    };

    document.getElementById('yes-btn').onclick = (e) => {
        e.stopPropagation();
        overlay.querySelector('.question').innerHTML = "æˆ‘å°±çŸ¥é“<br>ä½ ä¼šç­”åº”çš„ â¤ï¸";
        document.getElementById('yes-btn').style.display = 'none';

        let fwCount = 0;
        const fwInterval = setInterval(() => {
            launchFirework();
            fwCount++;
            if(fwCount > 10) clearInterval(fwInterval);
        }, 260);

        setTimeout(() => {
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
                overlay.style.opacity = '1';
                label.innerText = "ğŸ’‘ Forever Together ğŸ’‘";
            }, 500);
        }, 2500);
    };

    // =========================
    // ğŸ¥ åŠ¨ç”»
    // =========================
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        controls.update();
        if (treeMat) treeMat.uniforms.uTime.value = t;
        snowMat.uniforms.uTime.value = t;

        // æ ‘ï¼šæ…¢è½¬ + å‘¼å¸
        if (treeGroup.visible) {
            treeGroup.rotation.y = t * 0.10;
            const breathe = 1 + Math.sin(t * 1.10) * 0.03;
            treeGroup.scale.set(breathe, breathe, breathe);
        }

        // æ˜Ÿç©ºï¼šåˆ†å±‚æ…¢è½¬
        starGroup.children.forEach(o => o.rotation.y += o.userData.rot);

        // æ—‹æ¶¡ï¼šæ•´ä½“æ—‹è½¬
        vortexGroup.rotation.y = t * 0.14;
        vortexGroup.children.forEach(obj => {
            if (!obj.isPoints) return;
            if (obj.userData?.isDisk) { obj.rotation.y = -t * 0.06; return; }
            obj.rotation.y += (0.002 + obj.userData.band * 0.0006);
        });

        // ç›¸æœºæ¼‚æµ®
        camera.position.x = Math.sin(t * 0.12) * 1.1;
        camera.position.y = 12 + Math.sin(t * 0.18) * 0.55;
        camera.position.z = 54 + Math.cos(t * 0.12) * 0.9;
        camera.lookAt(0, 0, 0);

        // çˆ±å¿ƒåŠ¨ç”»
        if (heartGroup.visible) {
            heartGroup.rotation.y = Math.sin(t) * 0.28;
            const beat = 1 + Math.sin(t * 3) * 0.15;
            heartGroup.children[0].scale.set(2*beat, 2*beat, 2*beat);
            heartGroup.children[1].rotation.z -= 0.01;
        }

        // æ–‡å­—çˆ†ç‚¸
        textParticles.forEach(p => {
            if (!p.userData.exploding) return;
            const pos = p.geometry.attributes.position.array;
            const vels = p.userData.velocities;
            for (let i = 0; i < vels.length; i++) {
                pos[i*3]   += vels[i].x;
                pos[i*3+1] += vels[i].y;
                pos[i*3+2] += vels[i].z;
                vels[i].y  -= 0.02;
            }
            p.geometry.attributes.position.needsUpdate = true;
            p.material.opacity = Math.max(0, p.material.opacity - 0.012);
        });

        // çƒŸèŠ±ç‰©ç†
        for (let i = fireworks.length - 1; i >= 0; i--) {
            const fw = fireworks[i];
            fw.life -= 0.016;
            fw.sys.material.opacity = fw.life;

            const pos = fw.sys.geometry.attributes.position.array;
            for (let j = 0; j < fw.vel.length; j++) {
                pos[j*3]   += fw.vel[j].x;
                pos[j*3+1] += fw.vel[j].y;
                pos[j*3+2] += fw.vel[j].z;
                fw.vel[j].y -= 0.0048;
            }
            fw.sys.geometry.attributes.position.needsUpdate = true;

            if (fw.life <= 0) {
                scene.remove(fw.sys);
                fw.sys.geometry.dispose();
                fw.sys.material.dispose();
                fireworks.splice(i, 1);
            }
        }

        // çˆ†ç‚¸ç‰©ç†
        for (let i = bursts.length - 1; i >= 0; i--) {
            const b = bursts[i];
            b.life -= 0.02;
            b.sys.material.opacity = Math.max(0, b.life);

            const pos = b.sys.geometry.attributes.position.array;
            const vel = b.vel;

            for (let j = 0; j < vel.length/3; j++) {
                pos[j*3]   += vel[j*3];
                pos[j*3+1] += vel[j*3+1];
                pos[j*3+2] += vel[j*3+2];

                vel[j*3+1] -= 0.012;
                vel[j*3]   *= 0.985;
                vel[j*3+1] *= 0.985;
                vel[j*3+2] *= 0.985;
            }
            b.sys.geometry.attributes.position.needsUpdate = true;

            if (b.life <= 0) {
                scene.remove(b.sys);
                b.sys.geometry.dispose();
                b.sys.material.dispose();
                bursts.splice(i, 1);
            }
        }

        // =========================
        // æ¸²æŸ“ï¼šå…ˆ bloom(åªå¯¹ BloomLayer)ï¼Œå†åˆæˆ
        // =========================
        scene.traverse(darkenNonBloomed);
        bloomComposer.render();
        scene.traverse(restoreMaterial);

        finalComposer.render();
    }

    setStep(1);
    animate();

    // resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        bloomComposer.setSize(window.innerWidth, window.innerHeight);
        finalComposer.setSize(window.innerWidth, window.innerHeight);
        bloomPass.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
