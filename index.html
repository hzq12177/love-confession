<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas ğŸ„</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #0d1a2b 0%, #000000 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: absolute;
            bottom: 10%;
            text-align: center;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ï¼Œä¸å½±å“Canvas */
            z-index: 10;
            animation: float 3s ease-in-out infinite;
        }

        h1 {
            font-size: 3rem;
            margin: 0;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 40px #ff0000;
            font-family: 'Brush Script MT', cursive;
            background: linear-gradient(to right, #ff0000, #00ff00, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        p {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-top: 10px;
            letter-spacing: 2px;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* ç§»åŠ¨ç«¯é€‚é…è°ƒæ•´ */
        @media (max-width: 600px) {
            h1 { font-size: 2.5rem; }
            p { font-size: 1rem; }
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>Merry Christmas</h1>
        <p>Wishing you joy & happiness</p>
    </div>
    
    <canvas id="treeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];
        const particleCount = 1000; // ç²’å­æ•°é‡ï¼Œæ‰‹æœºç«¯å¦‚æœå¡é¡¿å¯é€‚å½“è°ƒå°
        let angle = 0;

        // å“åº”å¼ç”»å¸ƒå¤§å°
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // ç²’å­ç±»
        class Particle {
            constructor(type) {
                this.type = type; // 'tree' or 'snow'
                this.reset();
            }

            reset() {
                if (this.type === 'tree') {
                    // åœ£è¯æ ‘å½¢æ€é€»è¾‘ (åœ†é”¥èºæ—‹)
                    this.angle = Math.random() * Math.PI * 2;
                    this.h = Math.random(); // é«˜åº¦ 0-1
                    this.radius = (1 - this.h) * 200; // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„
                    this.y = (this.h * 400) - 200; // å‚ç›´ä½ç½®
                    this.speed = Math.random() * 0.02 + 0.01;
                    this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                    this.size = Math.random() * 2 + 1;
                } else {
                    // é›ªèŠ±é€»è¾‘
                    this.x = Math.random() * width;
                    this.y = Math.random() * height;
                    this.speed = Math.random() * 1 + 0.5;
                    this.size = Math.random() * 2;
                    this.drift = Math.random() * 0.5 - 0.25;
                }
            }

            update() {
                if (this.type === 'tree') {
                    this.angle += this.speed;
                } else {
                    this.y += this.speed;
                    this.x += this.drift;
                    if (this.y > height) this.y = 0;
                    if (this.x > width) this.x = 0;
                    if (this.x < 0) this.x = width;
                }
            }

            draw() {
                if (this.type === 'tree') {
                    // 3D æŠ•å½±è®¡ç®—
                    // è®©æ ‘æ—‹è½¬
                    const currentAngle = this.angle + angle;
                    const x = Math.cos(currentAngle) * this.radius;
                    const z = Math.sin(currentAngle) * this.radius;
                    
                    // ç®€å•çš„é€è§†æŠ•å½±
                    const perspective = 300 / (300 + z + 400); // æ‘„åƒæœºè·ç¦»
                    const px = x * perspective + width / 2;
                    const py = this.y * perspective + height / 2 - 50; // å‘ä¸Šåç§»ä¸€ç‚¹

                    // æ ¹æ®æ·±åº¦è°ƒæ•´é€æ˜åº¦å’Œå¤§å°
                    const alpha = (z + 200) / 400; 
                    
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = Math.max(0.1, alpha); // é˜²æ­¢é€æ˜åº¦ä¸ºè´Ÿ
                    ctx.beginPath();
                    ctx.arc(px, py, this.size * perspective, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = "white";
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // åˆå§‹åŒ–ç²’å­
        function init() {
            for (let i = 0; i < 800; i++) {
                particles.push(new Particle('tree'));
            }
            for (let i = 0; i < 200; i++) {
                particles.push(new Particle('snow'));
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            // å…¨å±€æ—‹è½¬é€Ÿåº¦
            angle += 0.005;

            // æŒ‰ç…§æ·±åº¦(zè½´)æ’åºï¼Œç¡®ä¿é®æŒ¡å…³ç³»æ­£ç¡®ï¼ˆç®€å•çš„ç”»å®¶ç®—æ³•ï¼‰
            particles.sort((a, b) => {
                if (a.type !== 'tree' || b.type !== 'tree') return 0;
                // è¿™é‡Œåªå¯¹æ ‘ç²’å­åšç®€å•æ’åºä¼˜åŒ–è§†è§‰
                const zA = Math.sin(a.angle + angle) * a.radius;
                const zB = Math.sin(b.angle + angle) * b.radius;
                return zA - zB;
            });

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // ç»˜åˆ¶é¡¶éƒ¨çš„æ˜Ÿæ˜Ÿ
            drawStar();

            requestAnimationFrame(animate);
        }

        function drawStar() {
            // æ˜Ÿæ˜Ÿçš„ä½ç½®éœ€è¦è·Ÿéšæ ‘çš„é¡¶éƒ¨æ—‹è½¬ï¼Œè¿™é‡Œç®€åŒ–ä¸ºå›ºå®šåœ¨ä¸­å¿ƒåä¸Šï¼Œä½†åŠ ä¸€ç‚¹å…‰æ™•
            const cx = width / 2;
            const cy = height / 2 - 250 * (300/700); // å¤§è‡´åœ¨æ ‘é¡¶
            
            ctx.save();
            ctx.translate(cx, cy);
            
            // æ˜Ÿæ˜Ÿå‘å…‰
            const time = Date.now() * 0.002;
            const scale = 1 + Math.sin(time) * 0.2;
            
            ctx.scale(scale, scale);
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#ffd700";
            
            ctx.fillStyle = "#ffd700";
            ctx.beginPath();
            // ç®€å•çš„è±å½¢æ¨¡æ‹Ÿæ˜Ÿæ˜Ÿ
            ctx.moveTo(0, -10);
            ctx.lineTo(3, -3);
            ctx.lineTo(10, 0);
            ctx.lineTo(3, 3);
            ctx.lineTo(0, 10);
            ctx.lineTo(-3, 3);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-3, -3);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        init();
        animate();
    </script>
</body>
</html>
