<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Only For You Â· E.dan</title>
    <style>
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body {
            margin: 0; overflow: hidden; background: #000;
            font-family: "PingFang SC", -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
        }
        #app {
            position: absolute; inset: 0; margin: auto;
            height: var(--vh, 100vh); width: 100vw;
            background: radial-gradient(circle at center, #0b1026 0%, #000000 100%);
            overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        #stage-label {
            position: absolute; top: 15px; left: 0; right: 0; text-align: center;
            pointer-events: none; z-index: 10; opacity: 0.85;
            text-shadow: 0 0 12px rgba(255,105,180,0.9);
            font-size: 12px; color: #ffb7b2; letter-spacing: 2px;
        }

        #final-overlay {
            position: absolute; inset: 0; display: none;
            align-items: center; justify-content: center; z-index: 100;
            backdrop-filter: blur(12px); background: rgba(0,0,0,0.7);
            transition: opacity 0.5s;
        }
        .box {
            background: rgba(30, 10, 30, 0.9); border-radius: 24px;
            padding: 32px 24px; text-align: center; width: 80%; max-width: 320px;
            border: 1px solid rgba(255,192,203,0.3);
            box-shadow: 0 0 60px rgba(255,0,100,0.35);
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .question { font-size: 20px; color: #fff; margin-bottom: 24px; line-height: 1.5; font-weight: 300; }
        .highlight { color: #ff69b4; font-weight: bold; }

        button#yes-btn {
            padding: 12px 36px; border-radius: 99px; border: none; font-size: 16px;
            background: linear-gradient(135deg, #ff69b4, #ff1493); color: #fff;
            box-shadow: 0 6px 20px rgba(255,20,147,0.5); cursor: pointer;
            transition: transform 0.2s;
        }
        button#yes-btn:active { transform: scale(0.95); }

        #mobile-controls {
            position: absolute; bottom: 30px; left: 0; right: 0;
            display: flex; flex-direction: column; gap: 12px; padding: 0 20px; z-index: 20;
        }
        .row { display: flex; gap: 10px; justify-content: center; }
        button.ctrl-btn {
            flex: 1; padding: 12px 0; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.9); font-size: 13px; backdrop-filter: blur(10px);
            transition: background 0.2s;
        }
        button.ctrl-btn:active { background: rgba(255,255,255,0.2); }
        .primary { border-color: rgba(255,105,180,0.4); color: #ffcae5; }
    </style>
</head>
<body>

<div id="app">
    <div id="stage-label">âœ¨ E.dan's Christmas Dream âœ¨</div>

    <div id="final-overlay">
        <div class="box">
            <div class="question">To <span class="highlight">E.dan</span><br>è¿™ä¸ªåœ£è¯èŠ‚<br>åšæˆ‘å¥³æœ‹å‹å¥½å—ï¼ŸğŸ„</div>
            <button id="yes-btn">æˆ‘æ„¿æ„ â¤ï¸</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="row">
            <button class="ctrl-btn" id="boom-btn">ğŸ’¥ çˆ†ç‚¸</button>
            <button class="ctrl-btn primary" id="fire-btn">ğŸ† çƒŸèŠ±</button>
            <button class="ctrl-btn" id="theme-btn">ğŸ¨ æ¢è‰²</button>
        </div>
        <div class="row">
            <button class="ctrl-btn" id="prev-btn">â—€ ä¸Šä¸€å¹•</button>
            <button class="ctrl-btn" id="next-btn">ä¸‹ä¸€å¹• â–¶</button>
        </div>
    </div>
</div>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
        "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
        "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js",

        "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
        "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
        "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"
      }
    }
</script>

<script type="module">
    // 1) è§†å£ä¿®æ­£ï¼ˆç§»åŠ¨ç«¯ 100vh é—®é¢˜ï¼‰
    function fixVh() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh * 100}px`);
    }
    fixVh(); window.addEventListener('resize', fixVh);

    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

    // --- é…ç½®ä¸­å¿ƒ ---
    const CONFIG = {
        text: { main: 'Merry', name: 'Christmas', love: 'I Love You' },
        colors: [
            { bg: '#0b1026', tree: [0x00ffcc, 0x0088ff], star: 0xffffff }, // æå…‰è“
            { bg: '#1a0505', tree: [0xff0055, 0xffaa00], star: 0xffdd00 }, // æš–å¿ƒçº¢
            { bg: '#050014', tree: [0xd000ff, 0x00ffff], star: 0xff00ff }, // èµ›åšç´«
        ]
    };
    let colorIdx = 0;

    // --- åœºæ™¯æ­å»º ---
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1026, 0.008);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
    camera.position.set(0, 12, 52);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    app.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.8;
    controls.maxDistance = 120;
    controls.minDistance = 12;

    // --- åæœŸ Bloomï¼ˆå…³é”®ï¼‰ ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.35,  // strength
        0.55,  // radius
        0.12   // threshold
    );
    composer.addPass(bloomPass);

    // åˆ›å»ºå‘å…‰ç‚¹çº¹ç†
    function createPointTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.35, 'rgba(255,255,255,0.55)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        const tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        return tex;
    }

    // ç»™æ–‡å­—/çƒŸèŠ±ç­‰ç”¨çš„åŸºç¡€ç²’å­æè´¨ï¼ˆä¿ç•™ï¼‰
    const particleMat = new THREE.PointsMaterial({
        size: 0.8,
        map: createPointTexture(),
        transparent: true,
        opacity: 0.9,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    // ======================================================
    // â‘  åœ£è¯æ ‘ï¼šNeon Shader ç²’å­ + æå…‰æµåŠ¨ + Twinkle
    // ======================================================
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);
    let treeGeometry = null;
    let treeMat = null;

    function createTreeShaderMaterial() {
        return new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            uniforms: {
                uTime: { value: 0 },
                uColorA: { value: new THREE.Color(CONFIG.colors[colorIdx].tree[0]) },
                uColorB: { value: new THREE.Color(CONFIG.colors[colorIdx].tree[1]) },
                uIntensity: { value: 1.35 },
                uTwinkle: { value: 1.0 },
                uPointScale: { value: 1.0 },
            },
            vertexShader: `
        attribute float aSize;
        attribute float aPhase;
        attribute float aP;
        varying float vP;
        varying float vGlow;
        varying float vPhase;

        uniform float uTime;
        uniform float uTwinkle;
        uniform float uPointScale;

        void main() {
          vP = aP;
          vPhase = aPhase;

          vec3 pos = position;

          // æå…‰æµåŠ¨ï¼šæ¨ªå‘è½»å¾®æ‰­åŠ¨ï¼Œé¡¶éƒ¨æ›´æŸ”å’Œ
          float flow = sin(uTime*0.9 + aPhase) * 0.25 + sin(uTime*1.7 + aP*12.0) * 0.12;
          pos.x += flow * (1.0 - aP) * 0.9;
          pos.z -= flow * (1.0 - aP) * 0.9;

          // twinkleï¼šæ¯ä¸ªç‚¹ç‹¬ç«‹é—ªçƒï¼ˆæ›´åƒç¯ä¸²ï¼‰
          float tw = sin(uTime*3.2 + aPhase) * 0.5 + 0.5;
          tw = mix(tw, pow(tw, 4.0), 0.65);
          vGlow = mix(0.55, 1.65, tw) * uTwinkle;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float dist = max(1.0, -mvPosition.z);
          float size = aSize * (240.0 / dist) * uPointScale;
          size *= (0.85 + 0.35 * sin(uTime*2.0 + aPhase));

          gl_PointSize = clamp(size, 1.0, 95.0);
        }
      `,
            fragmentShader: `
        precision highp float;
        varying float vP;
        varying float vGlow;
        varying float vPhase;

        uniform float uTime;
        uniform vec3 uColorA;
        uniform vec3 uColorB;
        uniform float uIntensity;

        void main() {
          vec2 uv = gl_PointCoord.xy - 0.5;
          float d = length(uv);

          float core = smoothstep(0.22, 0.0, d);
          float halo = smoothstep(0.60, 0.18, d);

          vec3 col = mix(uColorA, uColorB, smoothstep(0.0, 1.0, vP));
          col += 0.08 * sin(vec3(1.7, 2.3, 2.9) * (uTime*0.6 + vPhase));

          float alpha = (core * 0.95 + halo * 0.60) * vGlow;
          alpha *= (1.18 - smoothstep(0.35, 0.86, d));
          if(alpha < 0.02) discard;

          vec3 outCol = col * (uIntensity * (0.6 + 1.35*core + 0.55*halo));
          gl_FragColor = vec4(outCol, alpha);
        }
      `
        });
    }

    function createTree() {
        if (treeGeometry) treeGeometry.dispose();
        if (treeMat) treeMat.dispose();

        const count = 9000;

        const positions = new Float32Array(count * 3);
        const aSize = new Float32Array(count);
        const aPhase = new Float32Array(count);
        const aP = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            const p = i / (count - 1);
            const y = (p * 44) - 22;
            const radius = (1.0 - p) * 16.5;

            const angle = i * 2.39996 + Math.sin(p * 18.0) * 0.45;
            const garland = Math.sin(p * 30.0 + angle * 0.25) * 0.65;

            const layer = Math.floor(p * 18.0) / 18.0;
            const r = radius + garland * (1.0 - p) + (Math.random() - 0.5) * 0.55 + (layer - p) * 0.6;

            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            const puff = (1.0 - p) * (Math.random() - 0.5) * 1.2;

            positions[i * 3 + 0] = x + puff * Math.cos(angle * 1.7);
            positions[i * 3 + 1] = y + (Math.random() - 0.5) * 0.22;
            positions[i * 3 + 2] = z + puff * Math.sin(angle * 1.7);

            aSize[i] = (1.35 + Math.random() * 1.9) * (1.15 - p * 0.85);
            aPhase[i] = Math.random() * Math.PI * 2.0;
            aP[i] = p;
        }

        treeGeometry = new THREE.BufferGeometry();
        treeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        treeGeometry.setAttribute('aSize', new THREE.BufferAttribute(aSize, 1));
        treeGeometry.setAttribute('aPhase', new THREE.BufferAttribute(aPhase, 1));
        treeGeometry.setAttribute('aP', new THREE.BufferAttribute(aP, 1));

        // æ ‘é¡¶æ˜Ÿï¼šsprite flareï¼ˆæ›´è€€çœ¼ï¼‰
        const star = new THREE.Sprite(new THREE.SpriteMaterial({
            map: createPointTexture(),
            color: new THREE.Color(CONFIG.colors[colorIdx].star),
            transparent: true,
            blending: THREE.AdditiveBlending
        }));
        star.position.set(0, 22.5, 0);
        star.scale.set(10, 10, 1);

        // æ¸…ç©ºæ—§çš„
        while (treeGroup.children.length > 0) treeGroup.remove(treeGroup.children[0]);

        treeMat = createTreeShaderMaterial();
        const treePoints = new THREE.Points(treeGeometry, treeMat);

        treeGroup.add(treePoints);
        treeGroup.add(star);
    }

    createTree();

    // ======================================================
    // â‘¡ æ ‘å¤–èƒ½é‡ç¯ï¼šæ—‹è½¬â€œå…‰å¸¦ç¯â€ï¼ˆèƒ½é‡æ„Ÿï¼‰
    // ======================================================
    const energyRing = new THREE.Points(
        new THREE.BufferGeometry(),
        new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            uniforms: {
                uTime: { value: 0 },
                uColorA: { value: new THREE.Color(CONFIG.colors[colorIdx].tree[0]) },
                uColorB: { value: new THREE.Color(CONFIG.colors[colorIdx].tree[1]) },
                uIntensity: { value: 1.2 },
            },
            vertexShader: `
        attribute float aPhase;
        attribute float aSize;
        varying float vPhase;
        varying float vAlpha;

        uniform float uTime;

        void main() {
          vPhase = aPhase;

          vec3 pos = position;

          // ç¯å½¢æ³¢åŠ¨ï¼šè®©å…‰å¸¦â€œæ´»â€
          float wob = sin(uTime*1.4 + aPhase*3.0) * 0.55;
          pos.y += wob;

          // è½»å¾®å¾„å‘å‘¼å¸
          float breathe = 1.0 + 0.03 * sin(uTime*1.2 + aPhase);
          pos.x *= breathe;
          pos.z *= breathe;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float dist = max(1.0, -mvPosition.z);
          gl_PointSize = clamp(aSize * (200.0 / dist), 1.0, 50.0);

          // è®©ä¸åŒç›¸ä½é€æ˜åº¦ä¸åŒï¼Œå½¢æˆâ€œæ–­ç»­èƒ½é‡â€
          vAlpha = 0.6 + 0.4 * sin(uTime*2.0 + aPhase*6.0);
        }
      `,
            fragmentShader: `
        precision highp float;
        varying float vPhase;
        varying float vAlpha;

        uniform float uTime;
        uniform vec3 uColorA;
        uniform vec3 uColorB;
        uniform float uIntensity;

        void main() {
          vec2 uv = gl_PointCoord.xy - 0.5;
          float d = length(uv);

          float core = smoothstep(0.18, 0.0, d);
          float halo = smoothstep(0.60, 0.20, d);

          vec3 col = mix(uColorA, uColorB, 0.5 + 0.5*sin(vPhase + uTime*0.8));
          float a = (core*0.95 + halo*0.55) * clamp(vAlpha, 0.0, 1.0);

          if(a < 0.03) discard;

          vec3 outCol = col * (uIntensity * (0.7 + 1.4*core + 0.7*halo));
          gl_FragColor = vec4(outCol, a);
        }
      `
        })
    );
    energyRing.visible = true;
    scene.add(energyRing);

    function buildEnergyRing() {
        const count = 1600;
        const pos = new Float32Array(count * 3);
        const phase = new Float32Array(count);
        const size = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            const t = i / count * Math.PI * 2.0;
            // ç¯çš„åŸºç¡€åŠå¾„ï¼šç•¥å¤§äºæ ‘çš„åº•éƒ¨
            const baseR = 18.0;
            // åšæˆâ€œæ‰­æ›²çš„åŒå±‚ç¯â€ï¼Œæ›´æœ‰èƒ½é‡æ„Ÿ
            const twist = Math.sin(t * 2.0) * 1.2;
            const r = baseR + twist;

            const x = Math.cos(t) * r;
            const z = Math.sin(t) * r;

            // åˆ†å¸ƒåœ¨æ ‘ä¸­ä¸‹éƒ¨
            const y = -10.0 + Math.sin(t * 3.0) * 1.2;

            pos[i * 3 + 0] = x;
            pos[i * 3 + 1] = y;
            pos[i * 3 + 2] = z;

            phase[i] = Math.random() * Math.PI * 2.0;
            size[i] = 1.2 + Math.random() * 2.4;
        }

        energyRing.geometry.dispose();
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        g.setAttribute('aPhase', new THREE.BufferAttribute(phase, 1));
        g.setAttribute('aSize', new THREE.BufferAttribute(size, 1));
        energyRing.geometry = g;

        // åŒæ­¥é¢œè‰²
        energyRing.material.uniforms.uColorA.value.set(CONFIG.colors[colorIdx].tree[0]);
        energyRing.material.uniforms.uColorB.value.set(CONFIG.colors[colorIdx].tree[1]);
    }
    buildEnergyRing();

    // ======================================================
    // â‘¢ æ¼«å¤©é£˜é›ªï¼šå¸¦â€œæ™¯æ·±æ„Ÿâ€çš„å‘å…‰é›ªç²’å­ï¼ˆä¸æ˜¯ç™½ç‚¹ï¼‰
    // ======================================================
    const snow = new THREE.Points(
        new THREE.BufferGeometry(),
        new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            uniforms: {
                uTime: { value: 0 },
                uTex: { value: createPointTexture() },
                uIntensity: { value: 0.85 }
            },
            vertexShader: `
        attribute float aSize;
        attribute float aSpeed;
        attribute float aDrift;
        attribute float aPhase;
        varying float vAlpha;

        uniform float uTime;

        void main() {
          vec3 pos = position;

          // ä¸‹è½ + æ¨ªå‘æ¼‚ç§»ï¼ˆæ¯ç‰‡é›ªä¸åŒé€Ÿåº¦ï¼‰
          pos.y -= mod(uTime * aSpeed + aPhase, 90.0);
          pos.x += sin(uTime * 0.6 + aPhase) * aDrift;
          pos.z += cos(uTime * 0.55 + aPhase) * aDrift;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float dist = max(1.0, -mvPosition.z);
          gl_PointSize = clamp(aSize * (260.0 / dist), 1.0, 28.0);

          // è¿œå¤„æ›´æ·¡ï¼ˆæ¨¡æ‹Ÿæ™¯æ·±ï¼‰
          vAlpha = clamp(1.0 / (0.03 * dist), 0.12, 0.95);
        }
      `,
            fragmentShader: `
        precision highp float;
        varying float vAlpha;

        uniform sampler2D uTex;
        uniform float uIntensity;

        void main() {
          vec4 tex = texture2D(uTex, gl_PointCoord);
          float a = tex.a * vAlpha;
          if(a < 0.03) discard;

          // é›ªçš„é¢œè‰²ç•¥å¸¦å†·å…‰
          vec3 col = vec3(0.85, 0.95, 1.0) * uIntensity;
          gl_FragColor = vec4(col, a);
        }
      `
        })
    );
    scene.add(snow);

    function buildSnow() {
        const count = 2600;

        const pos = new Float32Array(count * 3);
        const size = new Float32Array(count);
        const speed = new Float32Array(count);
        const drift = new Float32Array(count);
        const phase = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            // å¤§èŒƒå›´é›ªåœºï¼ˆè¦†ç›–æ•´ä¸ªç”»é¢ï¼‰
            pos[i * 3 + 0] = (Math.random() - 0.5) * 140; // x
            pos[i * 3 + 1] = Math.random() * 90 + 10;     // yï¼ˆä»é«˜å¤„è½ä¸‹ï¼‰
            pos[i * 3 + 2] = (Math.random() - 0.5) * 160; // z

            // z è¶Šè¿œè¶Šå°ï¼ˆæ›´å¼ºæ™¯æ·±ï¼‰
            const z = Math.abs(pos[i * 3 + 2]);
            const depthFactor = 1.0 - Math.min(z / 160, 1.0);

            size[i] = (0.8 + Math.random() * 2.2) * (0.55 + depthFactor);
            speed[i] = 2.5 + Math.random() * 6.0; // æ¯ç‰‡é›ªä¸åŒé€Ÿåº¦
            drift[i] = 0.06 + Math.random() * 0.22;
            phase[i] = Math.random() * 90.0;
        }

        snow.geometry.dispose();
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        g.setAttribute('aSize', new THREE.BufferAttribute(size, 1));
        g.setAttribute('aSpeed', new THREE.BufferAttribute(speed, 1));
        g.setAttribute('aDrift', new THREE.BufferAttribute(drift, 1));
        g.setAttribute('aPhase', new THREE.BufferAttribute(phase, 1));
        snow.geometry = g;
    }
    buildSnow();

    // ==========================================
    // ğŸ’– 3D å®ä½“çˆ±å¿ƒ
    // ==========================================
    const heartGroup = new THREE.Group();
    scene.add(heartGroup);

    const heartShape = new THREE.Shape();
    heartShape.moveTo(0, 0);
    heartShape.bezierCurveTo(0, 3, -3, 3, -3, 0);
    heartShape.bezierCurveTo(-3, -3, 3, -3, 3, 0);
    heartShape.bezierCurveTo(3, 3, 0, 3, 0, 0);

    const heartGeo = new THREE.ExtrudeGeometry(heartShape, {
        depth: 2, bevelEnabled: true, bevelSegments: 3, steps: 2, bevelSize: 0.5, bevelThickness: 0.5
    });
    heartGeo.center();
    const heartMesh = new THREE.Mesh(heartGeo, new THREE.MeshPhongMaterial({
        color: 0xff1493, emissive: 0x550022, shininess: 200, specular: 0xffffff
    }));
    heartMesh.scale.set(2,2,2);
    heartGroup.add(heartMesh);

    const ringGeo = new THREE.BufferGeometry();
    const ringPos = [];
    for(let i=0; i<200; i++) {
        const t = i/200 * Math.PI * 2;
        const r = 8 + Math.random();
        ringPos.push(Math.cos(t)*r, (Math.random()-0.5)*2, Math.sin(t)*r);
    }
    ringGeo.setAttribute('position', new THREE.Float32BufferAttribute(ringPos, 3));
    const ring = new THREE.Points(
        ringGeo,
        new THREE.PointsMaterial({color: 0xff69b4, size: 0.3, transparent: true, blending: THREE.AdditiveBlending, depthWrite:false})
    );
    heartGroup.add(ring);
    heartGroup.visible = false;

    // ==========================================
    // ğŸ“ ç²’å­æ–‡å­—ç³»ç»Ÿ
    // ==========================================
    const textGroup = new THREE.Group();
    scene.add(textGroup);
    let textParticles = [];

    const loader = new FontLoader();
    loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
        function generateText(text, y, color) {
            const geo = new TextGeometry(text, { font: font, size: 3.5, height: 0.2, curveSegments: 6 });
            geo.center();

            const ptr = geo.attributes.position.array;
            const pts = [];
            const cols = [];
            const c = new THREE.Color(color);

            for(let i=0; i<ptr.length; i+=3) {
                if(Math.random() > 0.6) continue;
                pts.push(ptr[i], ptr[i+1] + y, ptr[i+2]);
                cols.push(c.r, c.g, c.b);
            }

            const buf = new THREE.BufferGeometry();
            buf.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
            buf.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));

            const p = new THREE.Points(buf, particleMat);
            p.userData = {
                velocities: new Array(pts.length/3).fill(0).map(()=>({x:0,y:0,z:0})),
                exploding: false
            };
            textGroup.add(p);
            textParticles.push(p);
        }

        generateText('Merry', 4, 0xff0055);
        generateText('Christmas', -2, 0x00ff88);
        textGroup.visible = false;
    });

    // ==========================================
    // ğŸ† çƒŸèŠ±ç³»ç»Ÿ
    // ==========================================
    const fireworks = [];
    function launchFirework() {
        const x = (Math.random()-0.5) * 40;
        const y = Math.random() * 20 + 10;
        const z = (Math.random()-0.5) * 40;
        const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);

        const count = 160;
        const pos = new Float32Array(count * 3);
        const vel = [];

        for(let i=0; i<count; i++) {
            pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 0.55 + 0.25;
            vel.push({
                x: Math.cos(angle) * speed,
                y: (Math.random()-0.5) * speed,
                z: Math.sin(angle) * speed
            });
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({
            size: 0.65, color: color, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const sys = new THREE.Points(geo, mat);
        scene.add(sys);
        fireworks.push({ sys, vel, life: 1.0 });
    }

    // ==========================================
    // ğŸ® é€»è¾‘æ§åˆ¶
    // ==========================================
    let step = 1;
    const overlay = document.getElementById('final-overlay');
    const label = document.getElementById('stage-label');

    function setStep(v) {
        step = v;
        treeGroup.visible = false;
        heartGroup.visible = false;
        textGroup.visible = false;
        overlay.style.display = 'none';

        if(step === 1) {
            treeGroup.visible = true;
            label.innerText = "âœ¨ The Starry Tree âœ¨";
        } else if (step === 2) {
            heartGroup.visible = true;
            label.innerText = "ğŸ’– My Heart For You ğŸ’–";
        } else if (step === 3) {
            textGroup.visible = true;
            label.innerText = "ğŸ„ Best Wishes ğŸ„";
        } else if (step === 4) {
            treeGroup.visible = true;
            overlay.style.display = 'flex';
            label.innerText = "ğŸ’Œ A Question... ğŸ’Œ";
        }
    }

    document.getElementById('next-btn').onclick = () => { if(step < 4) setStep(step+1); };
    document.getElementById('prev-btn').onclick = () => { if(step > 1) setStep(step-1); };

    document.getElementById('theme-btn').onclick = () => {
        colorIdx = (colorIdx + 1) % CONFIG.colors.length;
        const c = CONFIG.colors[colorIdx];

        scene.background = new THREE.Color(c.bg);
        scene.fog.color.set(c.bg);

        bloomPass.strength = colorIdx === 0 ? 1.35 : (colorIdx === 1 ? 1.55 : 1.75);
        bloomPass.radius = 0.55;
        bloomPass.threshold = 0.10;

        createTree();
        buildEnergyRing();

        // é›ªä¸éœ€è¦é‡å»ºï¼ˆä¹Ÿå¯ä»¥ä¸åŠ¨ï¼‰
    };

    document.getElementById('fire-btn').onclick = launchFirework;

    document.getElementById('boom-btn').onclick = () => {
        textParticles.forEach(p => {
            p.userData.exploding = true;
            p.userData.velocities.forEach(v => {
                v.x = (Math.random()-0.5);
                v.y = (Math.random()-0.5);
                v.z = (Math.random()-0.5);
            });
            p.material.opacity = 0.95;
        });
    };

    // è¡¨ç™½æŒ‰é’®é€»è¾‘
    const yesBtn = document.getElementById('yes-btn');
    yesBtn.onclick = (e) => {
        e.stopPropagation();

        overlay.querySelector('.question').innerHTML = "æˆ‘å°±çŸ¥é“<br>ä½ ä¼šç­”åº”çš„ â¤ï¸";
        yesBtn.style.display = 'none';

        let fwCount = 0;
        const fwInterval = setInterval(() => {
            launchFirework();
            fwCount++;
            if(fwCount > 10) clearInterval(fwInterval);
        }, 260);

        setTimeout(() => {
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
                overlay.style.opacity = '1';
                label.innerText = "ğŸ’‘ Forever Together ğŸ’‘";
            }, 500);
        }, 2500);
    };

    // ==========================================
    // ğŸ’¡ ç¯å…‰
    // ==========================================
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.85);
    keyLight.position.set(20, 30, 25);
    scene.add(keyLight);

    const pink = new THREE.PointLight(0xff3aa6, 0.9, 160);
    pink.position.set(-12, 8, 18);
    scene.add(pink);

    // ==========================================
    // ğŸ¥ åŠ¨ç”»å¾ªç¯
    // ==========================================
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        controls.update();

        // æ›´æ–° shader time
        if (treeMat) treeMat.uniforms.uTime.value = t;
        if (energyRing.material?.uniforms?.uTime) energyRing.material.uniforms.uTime.value = t;
        if (snow.material?.uniforms?.uTime) snow.material.uniforms.uTime.value = t;

        // æ ‘æ•´ä½“å‘¼å¸ + æ—‹è½¬ï¼ˆæ›´æ²‰æµ¸ï¼‰
        if(treeGroup.visible) {
            treeGroup.rotation.y = t * 0.12;
            const breathe = 1 + Math.sin(t * 1.35) * 0.035;
            treeGroup.scale.set(breathe, breathe, breathe);

            // èƒ½é‡ç¯ç»•æ ‘æ—‹è½¬ + ä¸Šä¸‹æµ®åŠ¨
            energyRing.rotation.y = -t * 0.55;
            energyRing.position.y = Math.sin(t * 0.9) * 0.35;
        }

        // çˆ±å¿ƒåŠ¨ç”»
        if(heartGroup.visible) {
            heartGroup.rotation.y = Math.sin(t) * 0.3;
            const beat = 1 + Math.sin(t * 3) * 0.15;
            heartGroup.children[0].scale.set(2*beat, 2*beat, 2*beat);
            heartGroup.children[1].rotation.z -= 0.01;
        }

        // ç²’å­æ–‡å­—çˆ†ç‚¸
        textParticles.forEach(p => {
            if(p.userData.exploding) {
                const pos = p.geometry.attributes.position.array;
                const vels = p.userData.velocities;
                for(let i=0; i<vels.length; i++) {
                    pos[i*3] += vels[i].x;
                    pos[i*3+1] += vels[i].y;
                    pos[i*3+2] += vels[i].z;
                    vels[i].y -= 0.02;
                }
                p.geometry.attributes.position.needsUpdate = true;
                p.material.opacity = Math.max(0, p.material.opacity - 0.012);
            }
        });

        // çƒŸèŠ±ç‰©ç†
        for(let i=fireworks.length-1; i>=0; i--) {
            const fw = fireworks[i];
            fw.life -= 0.016;
            fw.sys.material.opacity = fw.life;
            const pos = fw.sys.geometry.attributes.position.array;
            for(let j=0; j<fw.vel.length; j++) {
                pos[j*3] += fw.vel[j].x;
                pos[j*3+1] += fw.vel[j].y;
                pos[j*3+2] += fw.vel[j].z;
                fw.vel[j].y -= 0.005;
            }
            fw.sys.geometry.attributes.position.needsUpdate = true;
            if(fw.life <= 0) {
                scene.remove(fw.sys);
                fw.sys.geometry.dispose();
                fw.sys.material.dispose();
                fireworks.splice(i, 1);
            }
        }

        composer.render();
    }

    setStep(1);
    animate();

    // resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        bloomPass.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
