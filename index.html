<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Christmas Love Â· E.dan</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; overflow: hidden; background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    /* ç«–å± 9:16 å®¹å™¨ */
    #app {
      position: absolute; inset: 0; margin: auto;
      height: var(--vh, 100vh); aspect-ratio: 9 / 16; max-width: 100vw;
      border-radius: 0; overflow: hidden;
      background: radial-gradient(circle at top, #0f2027 0%, #203a43 60%, #2c5364 100%); /* åœ£è¯å¤œè‰²èƒŒæ™¯ */
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
    }
    canvas { display: block; width: 100%; height: 100%; }
    
    /* UI å…ƒç´  */
    #stage-label {
      position: absolute; top: 12px; right: 12px; z-index: 10;
      padding: 4px 10px; border-radius: 20px; font-size: 10px;
      color: #aaddff; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(4px);
    }
    #final-overlay {
      position: absolute; inset: 0; display: none;
      align-items: center; justify-content: center; z-index: 20;
      backdrop-filter: blur(10px); background: rgba(0,0,0,0.6);
    }
    #final-overlay .box {
      background: rgba(20, 30, 40, 0.9); border-radius: 20px;
      padding: 30px; text-align: center; border: 1px solid rgba(100,255,100,0.3);
      box-shadow: 0 0 30px rgba(0,255,127,0.2);
    }
    #final-overlay .question { font-size: 18px; color: #fff; margin-bottom: 20px; }
    #final-overlay button {
      padding: 10px 24px; border-radius: 20px; border: none; font-size: 16px; cursor: pointer;
      background: linear-gradient(135deg, #11998e, #38ef7d); color: #fff;
      box-shadow: 0 4px 15px rgba(56,239,125,0.4);
    }

    /* åº•éƒ¨æŒ‰é’®ç»„ */
    #mobile-controls {
      position: absolute; bottom: 20px; left: 0; right: 0;
      display: flex; flex-direction: column; gap: 10px; padding: 0 15px; z-index: 15;
    }
    .row { display: flex; gap: 8px; justify-content: center; }
    button.ctrl-btn {
      flex: 1; padding: 10px 0; border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.4);
      color: #fff; font-size: 12px; backdrop-filter: blur(8px);
    }
    button.ctrl-btn:active { background: rgba(255,255,255,0.2); transform: scale(0.98); }
    
    /* éšè— PC ç«¯ä¸éœ€è¦çš„ */
    @media (min-width: 768px) {
        #app { border-radius: 20px; max-height: 90vh; }
    }
  </style>
</head>
<body>

<div id="app">
  <div id="stage-label">Screen 1 / 6 Â· Snowy Night</div>
  
  <div id="final-overlay">
    <div class="box">
      <div class="question">è¿™ä¸ªåœ£è¯èŠ‚<br>åšæˆ‘å¥³æœ‹å‹å¥½å—ï¼ŸğŸ„</div>
      <button id="yes-btn">æˆ‘æ„¿æ„ â¤ï¸</button>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="row">
      <button class="ctrl-btn" id="boom-btn">ğŸ’¥ çˆ†ç‚¸æ–‡å­—</button>
      <button class="ctrl-btn" id="fire-btn">ğŸ† æ”¾çƒŸèŠ±</button>
      <button class="ctrl-btn" id="theme-btn">ğŸ¨ æ¢è‚¤</button>
    </div>
    <div class="row">
      <button class="ctrl-btn" id="prev-btn">â—€ ä¸Šä¸€æ­¥</button>
      <button class="ctrl-btn" id="next-btn">ä¸‹ä¸€æ­¥ â–¶</button>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
    "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
    "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js"
  }
}
</script>

<script type="module">
  function fixVh() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh * 100}px`);
  }
  fixVh(); window.addEventListener('resize', fixVh);

  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
  import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

  // --- é…ç½® ---
  const CONFIG = {
    mainWord: 'Merry',
    nameWord: 'Christmas',
    subWord: 'To My E.dan',
    timeline: [
        'First time we met',
        'Falling in love',
        'Forever together'
    ]
  };

  const app = document.getElementById('app');
  const stageLabel = document.getElementById('stage-label');

  // --- åœºæ™¯åˆå§‹åŒ– ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0f2027, 0.008); // é›¾æ°”åŠ é‡ï¼Œå¢åŠ æ°›å›´

  const camera = new THREE.PerspectiveCamera(60, app.clientWidth / app.clientHeight, 0.1, 500);
  camera.position.set(0, 5, 60);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(app.clientWidth, app.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  app.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;

  // --- ç¯å…‰ ---
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const pointLight = new THREE.PointLight(0xffaa00, 1.5, 100);
  pointLight.position.set(10, 20, 20);
  scene.add(pointLight);

  // ============================
  // ğŸ„ æ–°å¢ï¼š3D ç²’å­åœ£è¯æ ‘
  // ============================
  const treeGroup = new THREE.Group();
  scene.add(treeGroup);

  function createParticleTree() {
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const colors = [];
    const colorObj = new THREE.Color();
    
    // èºæ—‹æ ‘ä½“
    for(let i = 0; i < 1500; i++) {
        const t = i / 1500;
        const angle = t * Math.PI * 25; // æ—‹è½¬åœˆæ•°
        const radius = (1 - t) * 12;    // åº•éƒ¨å®½é¡¶éƒ¨å°–
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = t * 30 - 15;          // é«˜åº¦èŒƒå›´
        
        // åŠ å…¥ä¸€äº›éšæœºæ‰°åŠ¨ï¼Œè®©æ ‘çœ‹èµ·æ¥æ›´è‡ªç„¶
        vertices.push(x + (Math.random()-0.5), y, z + (Math.random()-0.5));
        
        // é¢œè‰²æ¸å˜ï¼šæ·±ç»¿ -> æµ…ç»¿ -> é¡¶ç«¯é‡‘è‰²
        if (t > 0.95) colorObj.set(0xffd700); // é¡¶ç«¯æ˜Ÿæ˜Ÿè‰²
        else colorObj.setHSL(0.35, 0.8, 0.3 + t * 0.4);
        
        colors.push(colorObj.r, colorObj.g, colorObj.b);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
        size: 0.6,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });
    
    const tree = new THREE.Points(geometry, material);
    treeGroup.add(tree);

    // æ ‘é¡¶æ˜Ÿæ˜Ÿ
    const starGeo = new THREE.OctahedronGeometry(1.5, 0);
    const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700, wireframe: true });
    const topStar = new THREE.Mesh(starGeo, starMat);
    topStar.position.y = 16;
    treeGroup.add(topStar);
    
    // æ ‘ä¸‹çš„å…‰æ™•
    const groundLight = new THREE.PointLight(0x00ff00, 0.5, 30);
    groundLight.position.set(0, -15, 0);
    treeGroup.add(groundLight);
  }
  createParticleTree();
  treeGroup.visible = true; // é»˜è®¤æ˜¾ç¤º

  // ============================
  // â„ï¸ æ–°å¢ï¼šé£˜é›ªæ•ˆæœ
  // ============================
  const snowGeo = new THREE.BufferGeometry();
  const snowCount = 1000;
  const snowPos = new Float32Array(snowCount * 3);
  const snowVel = new Float32Array(snowCount); // ä¸‹è½é€Ÿåº¦

  for(let i=0; i<snowCount; i++) {
      snowPos[i*3] = (Math.random() - 0.5) * 100;
      snowPos[i*3+1] = (Math.random() - 0.5) * 100;
      snowPos[i*3+2] = (Math.random() - 0.5) * 100;
      snowVel[i] = Math.random() * 0.1 + 0.05;
  }
  snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
  const snowMat = new THREE.PointsMaterial({
      color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
  });
  const snowSystem = new THREE.Points(snowGeo, snowMat);
  scene.add(snowSystem);

  // --- åŸæœ‰çš„å¿ƒå½¢ (ä¿ç•™ä½†è°ƒæ•´é€»è¾‘) ---
  const heartShape = new THREE.Shape();
  heartShape.moveTo(0, 0);
  heartShape.bezierCurveTo(0, 3, -3, 3, -3, 0);
  heartShape.bezierCurveTo(-3, -3, 3, -3, 3, 0);
  heartShape.bezierCurveTo(3, 3, 0, 3, 0, 0);
  const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.5, bevelThickness: 0.5 });
  heartGeo.center();
  const heartMat = new THREE.MeshPhongMaterial({ color: 0xff2b6c, emissive: 0xc90038, shininess: 100 });
  const heartMesh = new THREE.Mesh(heartGeo, heartMat);
  heartMesh.scale.set(2,2,2);
  heartMesh.visible = false; // åˆå§‹éšè—
  scene.add(heartMesh);

  // --- å­—ä½“åŠ è½½ & ç²’å­æ–‡å­— ---
  let particleTexts = [];
  const textGroup = new THREE.Group();
  scene.add(textGroup);
  
  const loader = new FontLoader();
  loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
      
      // åˆ›å»ºç²’å­æ–‡å­—å‡½æ•°
      function createTextParticles(text, yPos, color) {
          const geo = new TextGeometry(text, { font: font, size: 3, height: 0.2 });
          geo.center();
          const pts = geo.attributes.position.array;
          const vertices = [];
          // é™é‡‡æ ·ï¼Œå‡å°‘ç²’å­æ•°æé«˜æ€§èƒ½
          for(let i=0; i<pts.length; i+=9) { 
              vertices.push(pts[i], pts[i+1] + yPos, pts[i+2]);
          }
          const bufferGeo = new THREE.BufferGeometry();
          bufferGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          
          const mat = new THREE.PointsMaterial({ color: color, size: 0.3, sizeAttenuation: true });
          const particles = new THREE.Points(bufferGeo, mat);
          
          // ä¿å­˜åŸå§‹ä½ç½®ç”¨äºçˆ†ç‚¸åŠ¨ç”»
          particles.userData = { 
              originalPos: Float32Array.from(vertices), 
              velocities: new Float32Array(vertices.length).fill(0),
              exploding: false
          };
          
          textGroup.add(particles);
          particleTexts.push(particles);
      }

      createTextParticles(CONFIG.mainWord, 5, 0xff0000); // çº¢è‰²çš„ Merry
      createTextParticles(CONFIG.nameWord, -2, 0x00ff00); // ç»¿è‰²çš„ Christmas
      
      textGroup.visible = false;
  });

  // --- çƒŸèŠ±é€»è¾‘ (å¤ç”¨) ---
  const fireworks = [];
  function spawnFirework() {
      const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
      const geometry = new THREE.BufferGeometry();
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      
      for(let i=0; i<count; i++) {
          positions[i*3] = (Math.random()-0.5)*5;
          positions[i*3+1] = (Math.random()-0.5)*5 + 10;
          positions[i*3+2] = (Math.random()-0.5)*5;
          
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const speed = Math.random() * 0.5 + 0.5;
          velocities.push(
              Math.sin(phi)*Math.cos(theta)*speed,
              Math.sin(phi)*Math.sin(theta)*speed,
              Math.cos(phi)*speed
          );
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ size: 0.5, color: color, transparent: true });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      fireworks.push({ mesh: points, velocities: velocities, life: 1.0 });
  }

  // --- çŠ¶æ€æ§åˆ¶ ---
  let screenIndex = 1;
  const stages = [
      { name: 'é›ªå¤œåœ£è¯æ ‘', action: () => { treeGroup.visible = true; heartMesh.visible = false; textGroup.visible = false; } },
      { name: 'çˆ±çš„å½¢çŠ¶', action: () => { treeGroup.visible = false; heartMesh.visible = true; textGroup.visible = false; } },
      { name: 'ç²’å­è¡¨ç™½', action: () => { heartMesh.visible = false; textGroup.visible = true; } },
      { name: 'çƒŸèŠ±åº†å…¸', action: () => { setInterval(spawnFirework, 800); } },
      { name: 'ç»ˆæç­”æ¡ˆ', action: () => { document.getElementById('final-overlay').style.display = 'flex'; } }
  ];

  function updateScreen() {
      stageLabel.textContent = `Screen ${screenIndex} / 5 Â· ${stages[screenIndex-1].name}`;
      stages[screenIndex-1].action();
  }

  // æŒ‰é’®äº‹ä»¶
  document.getElementById('next-btn').onclick = () => { if(screenIndex < 5) { screenIndex++; updateScreen(); }};
  document.getElementById('prev-btn').onclick = () => { if(screenIndex > 1) { screenIndex--; updateScreen(); }};
  document.getElementById('fire-btn').onclick = spawnFirework;
  document.getElementById('boom-btn').onclick = () => {
      particleTexts.forEach(p => {
          p.userData.exploding = true;
          for(let i=0; i<p.userData.velocities.length; i++) p.userData.velocities[i] = (Math.random()-0.5) * 0.5;
      });
  };
  document.getElementById('yes-btn').onclick = function() {
      this.innerText = "çˆ±ä½  â¤ï¸ åœ£è¯å¿«ä¹";
      spawnFirework(); spawnFirework();
  };

  // --- åŠ¨ç”»å¾ªç¯ ---
  function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // 1. åœ£è¯æ ‘æ—‹è½¬
      treeGroup.rotation.y += 0.005;

      // 2. é£˜é›ª
      const pos = snowSystem.geometry.attributes.position.array;
      for(let i=0; i<snowCount; i++) {
          pos[i*3+1] -= snowVel[i]; // Yè½´ä¸‹è½
          if(pos[i*3+1] < -50) pos[i*3+1] = 50; // å¾ªç¯
      }
      snowSystem.geometry.attributes.position.needsUpdate = true;
      snowSystem.rotation.y += 0.001;

      // 3. å¿ƒè·³
      if(heartMesh.visible) {
          const s = 2 + Math.sin(Date.now()*0.003)*0.2;
          heartMesh.scale.set(s,s,s);
          heartMesh.rotation.y += 0.01;
      }

      // 4. ç²’å­çˆ†ç‚¸
      particleTexts.forEach(p => {
          if(p.userData.exploding) {
              const pos = p.geometry.attributes.position.array;
              for(let i=0; i<pos.length; i++) {
                  pos[i] += p.userData.velocities[i];
              }
              p.geometry.attributes.position.needsUpdate = true;
              p.material.opacity *= 0.98;
          } else {
             p.rotation.y = Math.sin(Date.now()*0.001) * 0.2;
          }
      });

      // 5. çƒŸèŠ±
      for(let i=fireworks.length-1; i>=0; i--) {
          const f = fireworks[i];
          f.life -= 0.02;
          f.mesh.material.opacity = f.life;
          const pos = f.mesh.geometry.attributes.position.array;
          for(let j=0; j<pos.length/3; j++) {
              pos[j*3] += f.velocities[j*3];
              pos[j*3+1] += f.velocities[j*3+1] - 0.05; // é‡åŠ›
              pos[j*3+2] += f.velocities[j*3+2];
          }
          f.mesh.geometry.attributes.position.needsUpdate = true;
          if(f.life <= 0) { scene.remove(f.mesh); fireworks.splice(i,1); }
      }

      renderer.render(scene, camera);
  }
  
  updateScreen(); // åˆå§‹åŒ–çŠ¶æ€
  animate();

</script>
</body>
</html>
